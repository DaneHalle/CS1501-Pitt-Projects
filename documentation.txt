====================================
CS/COE 1501 Assignment Documentation
------------------------------------
	I decided to utilize book provided code (MinPQ.java and MaxPQ.java) as a basis for implementing a PQ of apartments. From what I can tell these utilize a O(log(n)) runtime for the insert/remove/retrieve methods. I first combined and altered the two code files into a cut down version called MinMaxPQ.java. this takes out a lot of the boiler-plate that the book code had. I added three methods, contains() and two forms of remove(). contains() will utilize a BFS to check if an apartment is in the queue based on a given Street, Apartment#, and Zip and then return the location if found. This is utilized by my remove() methods. The remove() method essentially does the same as MinPQ and MaxPQ does for delMin/delMax methods respectively except the tree would start at location found from contains() instead of the root. The runtime for contains() can be O(n) should the apartment we are looking for is at the very bottom right of the theoretical tree or at location n in the PQ. 
	My approach for the city dependent PQ was a hash map of sorts. I made a class, cityHash(), that stores a String city and two PQs, a rentPQ and a squareFeetPQ. The way this class interacts with the rest of the code is with an array of length 257 that utilizes double hashing. The way I got as unique of a key as possible with the first hash function is by taking the ASCII value of each character within the city string and added it and then did total%257. If a city manage to hash to the same spot as a different city, I would add a second hash function to the first until an empty spot was found or the city spot was found. The second hash function was (total%101)+1. I chose both 257 and 101 because they are both prime numbers and have reasonable enough differences to almost guarantee that there will not be more than even one collision. I am not actually sure what the runtime of double hashing is and Google was not help. The best runtime for the it is O(1) which I know. 
	As for memory requirements, I will list each for each class:
apartments.java
	3 strings of size 8 * (int) ((((# chars) * 2) + 45) / 8) in terms of bytes
	2 ints of size 4 bytes
	1 double of size 8 bytes
RentComparator/SqFeetComparator
	Unknown size
MinMaxPQ.java
	1 boolean of size 8 byte
	1 array of apartments of varying size
	1 int of size 4 bytes
	1 comparator of some size
cityHash
	1 string of size 8 * (int) ((((# chars) * 2) + 45) / 8) in terms of bytes
	2 PQs of size determined by MinMaxPQ.java
AcTracker.java
	2 PQs of size determined by MinMaxPQ.java
	1 array of length 256 * size of cityHash

	
	